{"archive":{"blogPosts":[{"id":"mti-player","metadata":{"permalink":"/blog/mti-player","source":"@site/blog/2024-11-27-mti-player/2024-11-27-mti-player.md","title":"Reversing the MTI Player for Fun (and no profit!)","description":"MTI Player is a Mac-only app for playing licensed musical theatre tracks, but it's locked down with invasive security restrictions. Naturally, that made me curious.","date":"2024-11-27T00:00:00.000Z","tags":[{"inline":false,"label":"Proprietary","permalink":"/blog/tags/proprietary","description":"Reverse-engineering of proprietary software and protocols."},{"inline":false,"label":"Reverse-Engineering","permalink":"/blog/tags/reversing","description":"Reverse-engineering of software, protocols, and file formats."}],"readingTime":12.035,"hasTruncateMarker":true,"authors":[{"name":"N3rdL0rd","url":"https://github.com/N3rdL0rd","page":{"permalink":"/blog/authors/me"},"socials":{"github":"https://github.com/N3rdL0rd"},"imageURL":"https://github.com/N3rdL0rd.png","key":"me"}],"frontMatter":{"title":"Reversing the MTI Player for Fun (and no profit!)","description":"MTI Player is a Mac-only app for playing licensed musical theatre tracks, but it's locked down with invasive security restrictions. Naturally, that made me curious.","slug":"mti-player","authors":"me","tags":["proprietary","reversing"]},"unlisted":false,"nextItem":{"title":"CyberPanel Babuk Variant","permalink":"/blog/babuk-cyberpanel"}},"content":"## Introduction\n\nMTI (Musical Theatre International) Player is MTI's in-house software for playing production tracks for their licensed musicals. It's MacOS-only, it's a bit of a black box, and it's the only way to play production tracks (eg. non-watermarked tracks) for shows. For \"security reasons\" you have to also grant it permissions to record your screen, access your full disk, and it forces you to close out of specific other applications (the terminal, Finder, Safari, etc.) before it will play anything. Normally, I don't try to bypass security features like this, but when some software is *this* restrictive, I can't help but be curious as to what's going on under the hood - Also, I don't have a Mac, and I don't want to give Apple more money.\n\n<!-- truncate -->\n\n![MTI's FAQ: \"security features\"](image-1.png)\n\nThis phenomena in my brain reminds me a bit of the [Streisand Effect](https://en.wikipedia.org/wiki/Streisand_effect), which dictates that the more you try to hide something, the more people will end up finding out about it. For me at least, the more you try to restrict me from doing something with annoying \"security\" features and what seems to be borderline spyware, the more time I'll spend reversing it. But without further ado, let's start poking around.\n\n## Preliminary Analysis\n\nMTI also has a web app version of the player that can only play rehearsal tracks, which provides a great base to poke around, find their API endpoints, and see what information can be gleamed. The web app is just React, so it's really easy to see what's going on. The lackluster security of the web app is a good sign that the MacOS app is probably not much better, and the developers were kind enough to provide source maps and unminified code (with comments!), which was an amazing help. The source tree is available in `./player` if you're interested in poking around yourself, but you'll need a valid show rehearsal code. Anyway, here's the gist of it:\n\n- The web app uses GraphQL at `https://api.mtishows.com/graphql` to fetch show data and track URLs\n  - The GraphQL endpoint is protected by a bearer token that is stored in the web app's source, but it's not clear how it's generated. It doesn't seem to change between devices or sessions, so it's probably not tied to the user and instead tied to the app build itself. Those values, as of the time of writing, are:\n  - `X-Client-Id: 1b882a3e-747b-4f00-87f9-2b455735203e`\n  - `X-Platform-Id: 72095991-8343-4c89-9f95-eee6f5340224`\n\nLooking in `./player/js/data-graphql/*.js`, we can see a whole bunch of different files with various queries for the GraphQL API. The most interesting one is `./player/js/data-graphql/bookings.js`, which has a query for fetching track URLs:\n\n```gql\nquery getBookingForCode($rehearsalCode: String!) {\n  getBookingForCode(rehearsalCode: $rehearsalCode) {\n    rehearsal_tracks {\n      cue_number\n      track_name\n      time\n      time_formatted\n      location\n      track_id\n      __typename\n    }\n    show {\n      name\n      __typename\n    }\n    organization {\n      name\n      __typename\n    }\n    __typename\n  }\n}\n```\n\nYou can see a POC for this that allows you to easily download rehearsal tracks in `./poc_rehearsal.py`. But can we...\n\n```gql\nquery getBookingForCode($rehearsalCode: String!) {\n  getBookingForCode(rehearsalCode: $rehearsalCode) {\n    production_tracks { # <--\n      cue_number\n      track_name\n      time\n      time_formatted\n      location\n      track_id\n      __typename\n    }\n    __typename\n  }\n}\n```\n\nNo, we definitely can't.\n\n```json\n{\n  \"errors\": [\n    {\n      \"message\": \"Invalid auth token\",\n      \"locations\": [\n        {\n          \"line\": 3,\n          \"column\": 5\n        }\n      ],\n      \"path\": [\n        \"getBookingForCode\",\n        \"production_tracks\"\n      ],\n      \"extensions\": {\n        \"code\": \"INTERNAL_SERVER_ERROR\"\n      }\n    }\n  ],\n  \"data\": {\n    \"getBookingForCode\": {\n      \"production_tracks\": null,\n      \"__typename\": \"Booking\"\n    },\n    \"success\": false,\n    \"message\": \"Invalid auth token\"\n  }\n}\n```\n\n## The Plan\n\nNotably, the graphql query *didn't error*, which means that `production_tracks` is a valid field, but we're just not authorized to access it. This is a good sign that the MacOS app is probably just a thin wrapper around the web app, and that the API is at the very least probably the same. So, the plan is to:\n\n1. Reverse the MacOS app to see how it interacts with the API\n2. Figure out the login flow and how the token is generated\n3. Reimplement it in a way that allows us to fetch production tracks without a Mac\n4. ~~Profit!~~ Avoid profiting since that's illegal\n5. Share the knowledge with the world! (That's... uh, legal? Probably.)\n\nAlright, let's get to the fun stuff.\n\n## The MacOS App\n\n> [!NOTE]\n> The SHA256 of the ZIP archive containing the app used throughout this writeup is `65804943dc095b7615db26fbe9fa2065e4c23fb48eb54056e99c257408db4ade`. It is also attached in this folder.\n\nThe MacOS is compiled natively to MACH-O from Swift (ugh...) and a bit of Objective-C here and there. It's a bit of a mess in IDA, but it's not *too* hard to figure out the basics. Thankfully, there are still some debug symbols present that IDA can load, so we end up with a function list looking something like this:\n\n![IDA function list](image.png)\n\nThere are lots of junk functions that can be ignored, but the main one we're interested in (at least for recovering tokens from the auth flow) is `-[LoginViewController logInWithUsername:password:]` (at `0x000000010000D9AA`). Here's IDA's pseudocode:\n\n![pseudocode 1](image-2.png)\n\nAs you can see, it's a relatively simple callback-based login flow - all the buttons are disabled, a loading spinner gets shown, and the request is dispatched, and then the response is handled. Diving deeper, we see a call to `-[RestNetworking logInWithUsername:password:completion:]`, which is the very start of the actual networking code. It's really just a glorified wrapper in the end, and going deeper brings us to `sub_100028BD0` (renamed to `make_network_call_to_login` in the provided IDB), which creates a dictionary with the username and password, then calls to make the actual HTTP request. The pseudocode is very hard to read, but after some cleaning up we get something along the lines of:\n\n```json\n{\n  \"username\": \"username\",\n  \"password\": \"password\"\n}\n```\n\nThe actual network request is a bit of a pain:\n\n```c\nmake_http_request(1414745936LL, 0xE400000000000000LL, 'ningis/', 0xE700000000000000LL, _dict);// /signin\n```\n\nThe first thing you'll likely notice is how `/signin` is reversed as `ningis/`. Presumably, the request is a POST request with a JSON body, but we can't entirely be sure of that yet. Digging deeper, we can find this method:\n\n```c\nid __fastcall setup_restNetworking()\n{\n  void *self; // r13 removed struct type since it made it harder to read\n  objc_class *ObjectType; // r14\n  __int64 platformId; // rax\n  __int64 clientId; // rax\n  __int64 productionHost; // rax\n  __int64 stagingHost; // rax\n  char *urlComponents; // rbx\n  __int64 components_meta; // rax\n  objc_super super; // [rsp+0h] [rbp-20h] BYREF\n\n  ObjectType = swift_getObjectType(self);\n  platformId = OBJC_IVAR____TtC10MTI_Player14RestNetworking_platformId;\n  *(self + OBJC_IVAR____TtC10MTI_Player14RestNetworking_platformId) = 0xD000000000000024LL;\n  *(self + platformId + 8) = \"DownloadTrackProgressChange\" + 0x8000000000000000LL;\n  clientId = OBJC_IVAR____TtC10MTI_Player14RestNetworking_clientId;\n  *(self + OBJC_IVAR____TtC10MTI_Player14RestNetworking_clientId) = 0xD000000000000024LL;\n  *(self + clientId + 8) = \"13-9820-3727d263e140\" + 0x8000000000000000LL;\n  productionHost = OBJC_IVAR____TtC10MTI_Player14RestNetworking_productionHost;\n  *(self + OBJC_IVAR____TtC10MTI_Player14RestNetworking_productionHost) = 0xD000000000000010LL;\n  *(self + productionHost + 8) = \"00-87f9-2b455735203e\" + 0x8000000000000000LL;\n  stagingHost = OBJC_IVAR____TtC10MTI_Player14RestNetworking_stagingHost;\n  *(self + OBJC_IVAR____TtC10MTI_Player14RestNetworking_stagingHost) = 0xD000000000000018LL;\n  *(self + stagingHost + 8) = \"api.mtishows.com\" + 0x8000000000000000LL;\n  urlComponents = self + OBJC_IVAR____TtC10MTI_Player14RestNetworking____lazy_storage___urlComponents;\n  components_meta = type metadata accessor for URLComponents(0LL);\n  (*(*(components_meta - 8) + 56LL))(urlComponents, 1LL, 1LL, components_meta);// presumably a constructor\n  *(self + OBJC_IVAR____TtC10MTI_Player14RestNetworking____lazy_storage___headers) = 0LL;\n  *(self + OBJC_IVAR____TtC10MTI_Player14RestNetworking____lazy_storage___downloadsSession) = 0LL;\n  super.receiver = self;\n  super.super_class = ObjectType;\n  return objc_msgSendSuper2(&super, \"init\");\n}\n```\n\nThis is responsible for setting up the MTI_Player14RestNetworking class with the header values, which are:\n\n- `x-platform-id`: Set to \"DownloadTrackProgressChange\"\n- `x-client-id`: Set to \"13-9820-3727d263e140\"\n- `x-app-version`: Pulled from the main bundle's info dictionary\n- `x-device-id`: Generated at runtime via `sub_10002B740()`\n- `x-device-type`: Set to \"Mac\"\n- `x-device-desc`: Set to the machine's hostname (via `NSHost.currentHost().localizedName`)\n\nThis seems all well and good, but when we put it into Postman to test...\n\n![failure](image-3.png)\n\nDamn! So close. Again, looking at the client ID and platform ID from earlier, we can see that they're UUIDs - following the standard format of 8-4-4-4-12 hexadecimal digits separated by hyphens. Going back to the pseudocode, a few things jump out:\n\n```c\n  *(self + clientId + 8) = \"13-9820-3727d263e140\" + 0x8000000000000000LL;\n  productionHost = OBJC_IVAR____TtC10MTI_Player14RestNetworking_productionHost;\n  *(self + OBJC_IVAR____TtC10MTI_Player14RestNetworking_productionHost) = 0xD000000000000010LL;\n  *(self + productionHost + 8) = \"00-87f9-2b455735203e\" + 0x8000000000000000LL;\n  stagingHost = OBJC_IVAR____TtC10MTI_Player14RestNetworking_stagingHost;\n  *(self + OBJC_IVAR____TtC10MTI_Player14RestNetworking_stagingHost) = 0xD000000000000018LL;\n```\n\nYou can see there are two halves of what look to be UUIDs - presumably the ends. Cut past an hour of bashing my head against a wall with the pseudocode and I decided to open up IDA's strings view and search for the ends of the UUIDs. Lo and behold, there they were:\n\n![how did this take me so long?!?](image-4.png)\n\nThere are only two possible configurations - one's the client ID and the other is the platform ID. Sticking them in order (client, platform) into Postman, we get...\n\n![something!](image-5.png)\n\nYes! This is a slightly different error message, which means we're definitely getting closer. The error message is now `Invalid app info headers` which means we're at least getting the auth right. Presumably, the app info headers are `x-app-version`, `x-device-id`, `x-device-type`, and `x-device-desc`. The `x-app-version` is easy to get - looking at `Info.plist` from the app archive, we can see:\n\n```xml\n<key>CFBundleInfoDictionaryVersion</key>\n<string>6.0</string>\n<!-- ... -->\n<key>CFBundleShortVersionString</key>\n<string>1.2.1</string>\n<!-- ... -->\n<key>CFBundleVersion</key>\n<string>35</string>\n```\n\nI'm not a MacOS developer, so it took me an embarrassingly long time to realize that it's `CFBundleShortVersionString` that was the needed information rather than `CFBundleInfoDictionaryVersion`. `x-device-type` is just `Mac`, and `x-device-desc` is the hostname, which can be anything for our reimplementation. `x-device-id` is generated with this function:\n\n```c\n__int64 sub_10002B740()\n{\n  CFMutableDictionaryRef v0; // rax\n  const __CFDictionary *v1; // r14\n  io_service_t MatchingService; // r15d\n  __CFString *v3; // rsi\n  CFTypeRef CFProperty; // rbx\n  __int64 v6; // [rsp+8h] [rbp-38h] BYREF\n  CFTypeRef v7[5]; // [rsp+18h] [rbp-28h] BYREF\n\n  v0 = IOServiceMatching(\"IOPlatformExpertDevice\");\n  v1 = objc_retain(v0);\n  MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v1);\n  v3 = String._bridgeToObjectiveC()();\n  CFProperty = IORegistryEntryCreateCFProperty(MatchingService, v3, kCFAllocatorDefault, 0);\n  objc_release(v3);\n  IOObjectRelease(MatchingService);\n  if ( !CFProperty )\n    BUG();\n  swift_unknownObjectRetain(CFProperty);\n  objc_release(v1);\n  v7[0] = CFProperty;\n  swift_dynamicCast(&v6, v7, &type metadata for Swift.AnyObject + 8, &type metadata for String, 7LL);\n  return v6;\n}\n```\n\nAlthough this is a reasonably long function, it's basically doing the Swift/Obj-C equivalent of:\n\n```bash\nioreg -l | grep IOPlatformSerialNumber\n```\n\nSince I don't have a Mac to steal the serial number of, I'll instead graciously borrow one from Recorded Future's [tria.ge](https://tria.ge/dashboard) - thanks! On the MacOS sandbox I got randomly assigned, the serial number was `W80CD98B5PF`.\n\nPutting it all together, we get:\n\n```txt\nx-platform-id:bd6dbdd5-778d-4013-9820-3727d263e140\nx-client-id:1b882a3e-747b-4f00-87f9-2b455735203e\nx-device-type:Mac\nx-app-version:1.2.1\nx-device-desc:test-mac-hostname\nx-device-id:W80AA98A5PE\n```\n\nIncredibly, this works to authenticate! Now, back to that query we made earlier...\n\n```gql\nquery getBookingForCode($rehearsalCode: String!) {\n  getBookingForCode(rehearsalCode: $rehearsalCode) {\n    production_tracks {\n      cue_number\n      track_name\n      time\n      time_formatted\n      location\n      track_id\n      __typename\n    }\n    __typename\n  }\n}\n```\n\nLet's see if it works...\n\n![failure, again](image-6.png)\n\nAnd still nothing! This is the point where I assume further authentication is needed - since before, it was only based on the rehearsal code. Let's try making a call to `/signin` with the same body as before, but with a real account:\n\n![hm... what am I breaking?](image-7.png)\n\nFascinatingly, this returns a `500 Internal Server Error`, which is absolutely not what I was expecting. Let's go back to the MacOS app and see if we can find anything else.\n\n## Authentication Flow\n\n**Signing up:**\n\n![alt text](image-9.png)\n\n![alt text](image-8.png)\n\nAn account can be created by sending a `POST` to `https://api.mtishows.com/signup` with a JSON body of:\n\n```json\n{\n  \"first_name\": \"First\",\n  \"last_name\": \"Last\",\n  \"username\": \"username\",\n  \"password\": \"password\",\n  \"email\": \"email@email.com\"\n}\n```\n\nFor some reason, it will at first return a `500 Internal Server Error`:\n\n![alt text](image-10.png)\n\nBut if you retry the request...\n\n![alt text](image-11.png)\n\nIt seems to create the account just fine! The `500` is likely a bug in the API, but it's not a big deal for this purpose... yet. You can test that your account was created successfully by logging into the [web portal](https://player.mtishows.com/production) and looking for this error message:\n\n![alt text](image-12.png)\n\n**Logging in:**\n\nAt a cursory glance, the login flow seems to be just sending a `POST` request to `https://api.mtishows.com/signin` with a JSON body of:\n\n```json\n{\n  \"username\": \"username\",\n  \"password\": \"password\"\n}\n```\n\nBut, something doesn't quite work - it throws an internal server error whenever correct credentials are provided. This bug is the main stopping point for this writeup. So, I decided to suffer for science and try to set up a MITM proxy inside of an ephemeral VM on `tria.ge`. I used [Proxyman](https://proxyman.io/) to intercept the requests, and here's the methodology if you want to try it yourself:\n\n1. Set up a VM on `tria.ge` with a MacOS image\n2. Install Proxyman on the VM\n3. Install MTI Player on the VM\n4. Grant Proxyman the rights to intercept traffic (password is `root`)\n5. Open MTI Player and try to log in with incorrect credentials\n6. Check the Proxyman logs and double-click `/signin` to see the request body\n7. Grant Proxyman permission to decrypt HTTPS traffic for MTI Player\n8. Close and re-open MTI Player\n9. Log in with incorrect credentials, then correct credentials (to capture both)\n10. Save the request session to your Downloads\n11. Open a terminal: `cd Downloads`, `curl bashupload.com -T <session name>.proxymansession`\n12. Download the session file from your host\n\nThe session file is basically a compressed JSON file, which you can read using the attached `read_proxyman_session.py` script, eg:\n\n```txt\npython read_proxyman_session.py <session name>.proxymansession\n```\n\nThen, see `session.json` in the same directory.\n\n## Fixing Login\n\nLooking at the headers for a request in the captured session, we see:\n\n```txt\nHost:api.mtishows.com\nx-device-desc:test%E2%80%99s%20iMac\nAccept:application/json\nAccept-Encoding:gzip, deflate, br\nAccept-Language:en-us\nContent-Type:application/json\nx-platform-id:bd6dbdd5-778d-4013-9820-3727d263e140\nContent-Length:37\nx-client-id:1b882a3e-747b-4f00-87f9-2b455735203e\nx-device-id:79C87F0E-9237-5ABD-AA91-25F794E1F52E\nx-app-version:1.2.1\nUser-Agent:MTI%20Player/35 CFNetwork/1120 Darwin/19.0.0 (x86_64)\nConnection:keep-alive\nx-device-type:Mac\n```\n\nNotice that `x-device-id` is not a serial number of the format that we were using before, but instead a UUID. When adding this to the request, we get:\n\n![yes! yes! yesss!](image-13.png)\n\nThe body of the request is something other than an internal server error! This is a great start - let's look at the next request in the session, to `/graphql`:\n\n```txt\nHost:api.mtishows.com\nX-APOLLO-OPERATION-NAME:GetShows\nx-device-id:79C87F0E-9237-5ABD-AA91-25F794E1F52E\napollographql-client-version:1.2.1-35\nx-device-type:Mac\nAccept:*/*\nUser-Agent:MTI%20Player/35 CFNetwork/1120 Darwin/19.0.0 (x86_64)\nConnection:keep-alive\nAccept-Language:en-us\nAccept-Encoding:gzip, deflate, br\nContent-Type:application/json\nx-platform-id:bd6dbdd5-778d-4013-9820-3727d263e140\nContent-Length:1012\nx-client-id:1b882a3e-747b-4f00-87f9-2b455735203e\nx-auth-token:<censored, the same token as above>\napollographql-client-name:com.mtishows.mtimac-apollo-ios\nx-app-version:1.2.1\nX-APOLLO-OPERATION-TYPE:query\nx-device-desc:test%E2%80%99s%20iMac\n```\n\nLet's try adding the auth token to the GraphQL query we made earlier, and see what happens:\n\n![YES!!!!!](image-14.png)\n\nThat's it! We've successfully authenticated and fetched production tracks' URLs. You can see a complete POC in `./poc_production.py`.\n\n## Conclusion\n\nThis was a fun little project to work on, and I hope you enjoyed reading it as much as I enjoyed writing it. I'm not sure if I'll continue to work on this project, but I hope that this writeup can help others who are stuck with this abysmal software. As always, my IDB is attached. If you have any questions, feel free to reach out to me on Discord `@n3rdl0rd`.\n\n:heart: N3rdL0rd"},{"id":"babuk-cyberpanel","metadata":{"permalink":"/blog/babuk-cyberpanel","source":"@site/blog/2024-11-03-babuk-cyberpanel.md","title":"CyberPanel Babuk Variant","description":"This is a nasty little sample of ransomware that targets vulnerable CyberPanel instances for RCE, then encrypting VM images. However, it seems to have had its asymmetric encryption ripped entirely out!","date":"2024-11-03T00:00:00.000Z","tags":[{"inline":false,"label":"Malware","permalink":"/blog/tags/malware","description":"Reverse-engineering of malicious samples and analysis of malware campaigns."},{"inline":false,"label":"Reverse-Engineering","permalink":"/blog/tags/reversing","description":"Reverse-engineering of software, protocols, and file formats."}],"readingTime":3.31,"hasTruncateMarker":true,"authors":[{"name":"N3rdL0rd","url":"https://github.com/N3rdL0rd","page":{"permalink":"/blog/authors/me"},"socials":{"github":"https://github.com/N3rdL0rd"},"imageURL":"https://github.com/N3rdL0rd.png","key":"me"}],"frontMatter":{"title":"CyberPanel Babuk Variant","description":"This is a nasty little sample of ransomware that targets vulnerable CyberPanel instances for RCE, then encrypting VM images. However, it seems to have had its asymmetric encryption ripped entirely out!","slug":"babuk-cyberpanel","authors":"me","tags":["malware","reversing"]},"unlisted":false,"prevItem":{"title":"Reversing the MTI Player for Fun (and no profit!)","permalink":"/blog/mti-player"}},"content":"- Hash: `53bf41beef030d39bf962e0a267544cc6fc7f67954e14d6bdf3de7738f3e6e9f` (SHA256) from `./dont.run.me`\n- Platform: x64 ELF\n- Decompiled snippets are accessible in `./decompiled.c`.\n\nThis is a nasty little sample of ransomware that targets vulnerable CyberPanel instances for RCE, then encrypting VM images.\n\n<!-- truncate -->\n\n:::note\n\nFiles attached to this writeup can be found [here](https://github.com/N3rdL0rd/writeups/tree/main/CyberPanel-Babuk-Variant).\n\n:::\n\n## Writeup\n\n***main()***\n\nThe entry for the application is simple:\n\n```c\nint __fastcall main(int argc, char **argv)\n{\n  int num_processors; // eax\n  char *size_str; // rax\n\n  if ( argc == 2 )                              // executable name, path\n  {\n    num_processors = sysconf(84);               // _SC_NPROCESSORS_ONLN\n    thread_pool = create_threads(2 * num_processors);\n    putchar(10);\n    encrypt_dir(argv[1]);\n    join_threads(thread_pool);\n    destroy_threads(thread_pool);\n    putchar(10);\n    puts(\"Statistic:\");\n    puts(\"------------------\");\n    printf(\"Doesn't encrypted files: %d\\n\", total_file_count - total_encrypted_count - skipped_file_count);\n    printf(\"Encrypted files: %d\\n\", total_encrypted_count);\n    printf(\"Skipped files: %d\\n\", skipped_file_count);\n    printf(\"Whole files count: %d\\n\", total_file_count);\n    size_str = format_size(total_encrypted_size);\n    printf(\"Crypted: %s\\n\", size_str);\n    puts(\"------------------\");\n    putchar(10);\n  }\n  else\n  {\n    printf(\"Usage: %s /path\\n\", *argv);\n  }\n  return 0;\n}\n```\n\nInterestingly, this sample seems to only encrypt the directory that it's passed, making it safe<sup>[1](#footnotes)</sup> to detonate on most systems. It uses a thread pool (see the C Thread Pool library<sup>[[3]](#references)</sup>) to encrypt files quickly and it prints a final count in the same format as Babuk.\n\n***find_files_recursive()*** - *encrypt_dir()* in the attached decompilation\n\nThis is the actual meat and potatoes of this sample, and is one of the two major functions that was modified from the leaked Babuk source<sup>[[2]](#references)</sup>. Because this function is so long, it is not included here.\n\nAt it's core, this is nothing but a simple directory crawler. It goes through the directory it's given recursively and writes a ransom note to the root of it. Notably, the ransomware will **only** encrypt the files with following extensions:\n\n`.frm, .idb, .php, .bak, .sql, .MYD, .MYI, .opt, .js, .css, .html, .svg, .woff, .woff2, .eot, .ico, .png, .jpg, .jpeg, .gif, .mp4, .asp, .jsp, .mp3, .zip, .gz, .tar, .bz2, .json, .bk, .doc, .pdf, .xlsx, .xls, .xlt, .et, .xlsm, .db, .csv, .xltx, .xltm, .mht, .mhtml, .dbf, .mdb, .vue`\n\n:::note\n\nSome sub-variants will check for other file extensions, specifically: `.log, .vmx, .ovf, .vmdk, .vmxf, .vmsd, .vmsn, .vswp, .vmss, .vmem, .nvram, .ova`\n\n:::\n\n***encrypt_file()***\n\nThis is the other major modified function in the sample. In the original Babuk, ECC is used to generate an ephemeral encryption key for SOSEMANUK<sup>[[1]](#references)</sup> (a semi-obscure stream cipher), but in this sample, this functionality is removed and is instead replaced with a SHA256 hash of an uninitialized byte array with length `32` - which results in the following key:\n\n```txt\n          00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F\n \n00000000  D7 F1 D7 DB 06 37 B3 71  F7 BC 73 92 16 5A 47 2D\n00000010  A2 96 67 66 B8 A7 58 06  C7 73 2B 21 30 03 64 C6\n```\n\nThis key is fed directly to SOSEMANUK to encrypt the file in 10MB chunks, with a trailing set of 32 bytes of zeros. If these zeros are included in normal decryption, they can cause invalid data to be returned - make sure to ignore them during decryption.\n\n## Decryptor\n\nA proof-of-concept decryptor for files encrypted by the sample is included in the `./decrypt` folder, and a sample of an encrypted file is located at `./test.json.encryp`.\n\nUsage:\n\n```txt\ndecrypt <encrypted_file> <output_file> <key_file>\n```\n\n## Indicators of Compromise\n\n***Filename***\n\n- `*.encryp`\n- `help-readme.txt`\n\n***Hashes***\n\n- SHA256: `53bf41beef030d39bf962e0a267544cc6fc7f67954e14d6bdf3de7738f3e6e9f`\n- SHA256: `113c3c3aeafbc59615cc23cd47b0cb1f22145ed6d7bfeca283c3fdf4d8076881`\n- SHA256: `a1145bfafd1fe4ab5db7d03836af4289d0622bf596f30a50320accb02e337157`\n\n***Other***\n\n- TOX ID: `970F104D828F2696FF2508C0EFB3BEAB3220DFF8B7A45EBFBE86A1DBE2830B62CEBB32248B46`\n- TOX ID: `A162BBD93F0E3454ED6F0B2BC39C645E9C4F88A80B271A93A4F55CF4B8310C2E27D1D0E0EE1B`\n\n:::note\n\nA YARA rule is available in `./cyberpanel_babuk_variant.yara`.\n\n:::\n\n## Footnotes\n\n1. Although running the sample on a folder is most likely safe, it is still advisable to run this in a VM due to potentially destructive actions being taken.\n\n## References\n\n1. The leaked [Babuk Ransomware Source](https://github.com/Hildaboo/BabukRansomwareSourceCode), from some random archive on GitHub\n2. The eSTREAM Project's [documentation on SOSEMANUK](https://web.archive.org/web/20210507120806/https://www.ecrypt.eu.org/stream/sosemanukpf.html), and [Wikipedia too](https://en.wikipedia.org/wiki/SOSEMANUK)\n3. The [C Thread Pool](https://github.com/Pithikos/C-Thread-Pool) library\n\nAnd a profound thank you to you, dear reader, for suffering through this poorly written writeup, which was made with :heart: by N3rdL0rd."}]}}